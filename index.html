<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Swd programing sram : Programming internal SRAM over ARM Cortex M3 SWD" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Swd programing sram</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/MarkDing/swd_programing_sram">View on GitHub</a>

          <h1 id="project_title">Swd programing sram</h1>
          <h2 id="project_tagline">Programming internal SRAM over ARM Cortex M3 SWD</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/MarkDing/swd_programing_sram/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/MarkDing/swd_programing_sram/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="programming-internal-sram-over-swd" class="anchor" href="#programming-internal-sram-over-swd"><span class="octicon octicon-link"></span></a>Programming internal SRAM over SWD</h1>

<h2>
<a name="1-introduction" class="anchor" href="#1-introduction"><span class="octicon octicon-link"></span></a>1. Introduction</h2>

<p>This documentation describe how to programming ARM Cortex M3 internal SRAM over SWD(Serial Wire Debug) interface. For this purpose, something we too know.</p>

<ul>
<li>SWD communication protocol.
We need to know Low level timing requirement, that is  foundation to exchange command and data between debugger and target MCU.</li>
<li>Read/write data from/to internal SRAM.
We need to know how to program firmware into desired address, like SRAM(0x20000000). That needs us to know SW-DAP registers usage. Pass address and data over those registers and then into internal SRAM.</li>
<li>Make code running from SRAM.
We need to change vector table entry from internal flash to SRAM; And SP and PC also needed change to SRAM location. That need us to know the cortex M3 debug and system registers usage.</li>
</ul><p>We choose Silabs SiM3U167 as target MCU in this implementation. We implement a high level protocol with python script, it calls Silabs provided DLL file interface to access Silabs USB Debug Adapter. Also, we provide a firmware running from C8051F380, it contains a full implementation on both low level communicating timing and high level programming SRAM protocol.</p>

<h2>
<a name="2-serial-wire-debug-overview" class="anchor" href="#2-serial-wire-debug-overview"><span class="octicon octicon-link"></span></a>2. Serial Wire Debug overview</h2>

<p>Serial Wire Debug (SWD) is a 2-pin (SWDIO/SWCLK) electrical alternative JTAG interface that has the same JTAG protocol on top. SWD uses an ARM CPU standard bi-directional wire protocol, defined in the ARM Debug Interface v5. This enables the debugger to become another AMBA bus master for access to system memory and peripheral or debug registers.</p>

<p>The Debug Access Port(DAP) is split into two main control units.  the Debug Port (DP) and the Access Port (AP), and the physical connection to the debugger is part of the DP. The DAP supports two types of access, Debug Port (DP) accesses and Access Port (AP)accesses. External device to communicate directly with Serial Wire Debug Port(SW-DP) over SWDIO/SCLK pins. And SW-DP in turn can access one or several Access Ports(APs) the give access to the rest of the system. The MEM-AP is important AP which provide a way to access all memory and peripheral registers residing on the internal AHB/APB buses.</p>

<p><strong>Figure 1 ARM Debug Interface MEM-AP Implementation</strong></p>

<p><img src="https://raw.github.com/MarkDing/swd_programing_sram/master/images/adi_mem-ap.png" alt="ADI MEM-AP" title="ARM Debug Interface MEM-AP Implementation"></p>

<p>One of the four registers within the DP is the AP Select Register, SELECT. This register specifies a particular Access Port, and a bank of four 32-bit words within the register map of that AP. It enables up to 256 Access Ports to be implemented, and gives access to any one of 16 four-word banks of registers on the selected AP.</p>

<h2>
<a name="3-swd-protocol" class="anchor" href="#3-swd-protocol"><span class="octicon octicon-link"></span></a>3. SWD protocol</h2>

<p>This section gives an overview of the bi-directional operation of the protocol. It illustrates each of the possible sequences of operations on the Serial Wire Debug interface data connection.</p>

<h3>
<a name="31-connection-and-line-reset-sequence" class="anchor" href="#31-connection-and-line-reset-sequence"><span class="octicon octicon-link"></span></a>3.1. Connection and line reset sequence</h3>

<p>The SW-DP must use connection sequence of 50 clock cycles with data = 1. And this sequence is also used as a line reset sequence which requires 50 consecutive 1s on the data input.</p>

<p><strong>JTAG to SWD switching</strong></p>

<p>SWJ-DP enables either an SWD or JTAG protocol to be used on the debug port. To do
this, it implements a watcher circuit that detects a specific 16-bit selection sequence on the SWDIOTMSpin:</p>

<p>The 16-bit JTAG-to-SWD select sequence is defined to be 0b0111100111100111, MSB first. This can be represented as 16'h79E7 if transmitted MSB first or 16'hE79E if transmitted LSB first.</p>

<p>The host must read IDCODE register after line request sequence. This requirement gives confirmation that correct packet frame alignment has been achieved.</p>

<h3>
<a name="32-successful-transaction-operation" class="anchor" href="#32-successful-transaction-operation"><span class="octicon octicon-link"></span></a>3.2. Successful transaction operation</h3>

<p>A successful transaction contains three phases.</p>

<ul>
<li>Host sending an eight-bit write packet request to target.</li>
<li>Target response with a three-bit OK acknowledge to host.</li>
<li>A 33-bit data phase, either from host or target depends on write/read operation.</li>
</ul><p><strong>Figure 2 Serial Wire Debug successful write operation</strong></p>

<p><img src="https://raw.github.com/MarkDing/swd_programing_sram/master/images/swd-write-portocol.png" alt="SWD write operation" title="Serial Wire Debug successful write operation"></p>

<h3>
<a name="321-packet-request-phase" class="anchor" href="#321-packet-request-phase"><span class="octicon octicon-link"></span></a>3.2.1. Packet request phase</h3>

<p>The request phase consists of 8 bits. The meaning of each bit in the request is illustrated below.</p>

<ul>
<li>
<code>Start</code> -- A single start bit, with value 1.</li>
<li>
<code>APnDP</code> -- A single bit, indicating whether the Debug Port or the Access Port Access Register is to be accessed. 1 for accessing AP.</li>
<li>
<code>RnW</code> -- A single bit, this bit is 0 for an write access, or 1 for a read access.</li>
<li>
<code>A[2:3]</code> -- Two bits, giving the A[3:2] address field for the DP or AP register address.</li>
<li>
<code>Parity</code> -- A single odd parity bit is made over the APnDP, RnW and A[2:3] bits. The number of bits set to 1 is odd, then the parity bit is set to 1.</li>
<li>
<code>Stop</code> -- A single stop bit. In the synchronousSWD protocol this is always 0.</li>
<li>
<code>Park</code> -- A single bit, with value 1.</li>
</ul><h3>
<a name="322--acknowledge-response-phase" class="anchor" href="#322--acknowledge-response-phase"><span class="octicon octicon-link"></span></a>3.2.2.  Acknowledge response phase</h3>

<p>ACK phase is a three-bit(LSB-first) target to host response. Three type ACK response.</p>

<ul>
<li>
<code>OK Response</code> -- It indicates successful operation, value is b001.</li>
<li>
<code>WAIT response</code> -- The host must retry the operation later, value is b010.</li>
<li>
<code>FAULT response</code> --  If the target responds with FAULT, an error has occurred
and one of the sticky bits in CTRL/STAT is set. The host can check the sticky error bits to see what kind of error has occurred. It must clear the sticky bits in  ABORT register before using any AP commands, because the target will always respond with FAULT as long as one of the sticky error bits are set. Value is b100.</li>
</ul><h3>
<a name="323-data-transfer-phase" class="anchor" href="#323-data-transfer-phase"><span class="octicon octicon-link"></span></a>3.2.3. Data transfer phase</h3>

<p>It contains 32 data bits and 1 parity bit. The The parity check is made over the 32 data bits. The number of bits set to 1 is odd, then the parity bit is set to 1.</p>

<h3>
<a name="324-turnaround-period" class="anchor" href="#324-turnaround-period"><span class="octicon octicon-link"></span></a>3.2.4. Turnaround period</h3>

<p>From figure above, there is <code>Trn</code> -- Turnaround period between each phase. Every  time  the  SWDIO  changes  data  direction,  a  one-cycle  turnaround  period  is  inserted  which both sides should ignore. This means there is always a turnaround period between the request and acknowledge. On a write request, there is a turnaround period between acknowledge and the data phase. On a read request there is a a turnaround after the data phase.</p>

<h2>
<a name="4-serial-write-debug-portsw-dp-registers" class="anchor" href="#4-serial-write-debug-portsw-dp-registers"><span class="octicon octicon-link"></span></a>4. Serial Write Debug Port(SW-DP) Registers</h2>

<p>This section will give a brief overview over the SW-DP registers.</p>

<p><strong>Table 1 SW-DP registers</strong></p>

<table>
<thead><tr>
<th>Address</th>
<th>Read</th>
<th>Write</th>
</tr></thead>
<tbody>
<tr>
<td>0x00</td>
<td>IDCODE</td>
<td>ABORT</td>
</tr>
<tr>
<td>0x04</td>
<td>CTRL/STAT</td>
<td>CTRL/STAT</td>
</tr>
<tr>
<td>0x08</td>
<td>RESEND</td>
<td>SELECT</td>
</tr>
<tr>
<td>0x0C</td>
<td>RDBUFF</td>
<td>N/A</td>
</tr>
</tbody>
</table><h3>
<a name="41-the-identification-code-register-idcode" class="anchor" href="#41-the-identification-code-register-idcode"><span class="octicon octicon-link"></span></a>4.1. The Identification Code Register, IDCODE</h3>

<p><code>IDCODE</code> register provides a identification information about SW-DP. On the EFM32 or SiM3U devices with a Cortex-M3 or Cortex-M4 core this register should read 0x2BA01477. For devices with a CortexM0+ core the register should read 0x0BC11477.</p>

<h3>
<a name="42-the-ap-abort-register-abort" class="anchor" href="#42-the-ap-abort-register-abort"><span class="octicon octicon-link"></span></a>4.2. The AP Abort Register, ABORT</h3>

<p><code>ABORT</code> register main purpose is to force a DAP abort, and on a SW-DP it is also used to clear error and sticky flag conditions. Here are the bit assignments of AP Abort register.</p>

<p><strong>Table 2 ABORT register bit assignments</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>[31:5]</td>
<td>-</td>
<td>Reserved</td>
</tr>
<tr>
<td>[4]</td>
<td>ORUNERRCLR</td>
<td>Write 1 to this bit to clear the STICKYORUN overrun error flag to 0.</td>
</tr>
<tr>
<td>[3]</td>
<td>WDERRCLR</td>
<td>Write 1 to this bit to clear the WDATAERR write data error flag to 0</td>
</tr>
<tr>
<td>[2]</td>
<td>STKERRCLR</td>
<td>Write 1 to this bit to clear the STICKYERR sticky error flag to 0.</td>
</tr>
<tr>
<td>[1]</td>
<td>STKCMPCLRa</td>
<td>Write 1 to this bit to clear the STICKYCMP sticky compare flag to 0.</td>
</tr>
<tr>
<td>[0]</td>
<td>DAPABORT</td>
<td>Write 1 to this bit to generate a DAP abort. This aborts the current AP transaction. Do this only if the debugger has received WAIT responses over an extended period.</td>
</tr>
</tbody>
</table><p>You might want to find what caused the flag to be set to 1. Typically:</p>

<ul>
<li>For the <code>STICKYCMP</code> or <code>STICKYERR</code> flag, you must find which location was accessed to cause the flag to be set to 1.</li>
<li>For the <code>WDATAERR</code> flag, you must resend the corrupted data.</li>
<li>For the <code>STICKYORUN</code> flag, you must find which DP or AP transaction caused the overflow. You then have to repeat your transactions from that point.</li>
</ul><h3>
<a name="43-the-controlstatus-register-ctrlstat" class="anchor" href="#43-the-controlstatus-register-ctrlstat"><span class="octicon octicon-link"></span></a>4.3. The Control/Status Register, CTRL/STAT</h3>

<p><code>CTRL/STAT</code> register provides control of the DP and status information about the DP.</p>

<p><strong>Figure 3 Control/Status Register bit assignments</strong></p>

<p><img src="https://raw.github.com/MarkDing/swd_programing_sram/master/images/ctrl-stat-reg.png" alt="CTRL/STAT" title="Control/Status Register bit assignments"></p>

<ul>
<li>Bit [28] <code>CDBGPWRUPREQ</code> is the signal from the debug interface to the power controller, used to request the system power controller to fully power-up and enable clocks in the debug power
domain.</li>
<li>Bit [30] <code>CSYSPWRUPREQ</code> is the signal from the debug interface to the power controller, used to request the system power controller to fully power-up and enable clocks in the system power domain.</li>
</ul><p>The debugger must write a 1 to the CDBGPWRUPREQ and CSYSPWRUPREQ bits before using the AHB-AP. The STICKYERR bit is set if an error is returned by a AP transaction. While the STICKYERR bit is set any SWD request will return a FAULT response. To clear the STICKYERR bit, use the ABORT register.</p>

<h3>
<a name="44-the-ap-select-register-select" class="anchor" href="#44-the-ap-select-register-select"><span class="octicon octicon-link"></span></a>4.4. The AP Select Register, SELECT</h3>

<p><code>SELECT</code> register specifies a particular Access Port, and a bank of four 32-bit words within the register map of that AP. It enables up to 256 Access Ports to be implemented, and gives access to any one of 16 four-word banks of registers on the
selected AP.</p>

<p><strong>Table 3 Bit assignments for the AP Select Register, SELECT</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>[31:24]</td>
<td>APSEL</td>
<td>Selects the current AP.</td>
</tr>
<tr>
<td>[7:4]</td>
<td>APBANKSEL</td>
<td>Selects the active four-word register bank on the current AP</td>
</tr>
</tbody>
</table><h3>
<a name="45-the-read-buffer-rdbuff" class="anchor" href="#45-the-read-buffer-rdbuff"><span class="octicon octicon-link"></span></a>4.5. The Read Buffer, RDBUFF</h3>

<p><code>RDBUFF</code> register return the result of a previous read, without initiating a new AP transaction.</p>

<p>If you require the value from an AP register read, that A read of the DP Read Buffer must be followed.</p>

<h2>
<a name="5-memory-access-portmem-ap-registers" class="anchor" href="#5-memory-access-portmem-ap-registers"><span class="octicon octicon-link"></span></a>5. Memory Access Port(MEM-AP) Registers</h2>

<p>A MEM-AP provides a DAP with access to a memory subsystem. Since memory, peripherals and debug components are all memory mapped, the MEM-AP can be used to both program and debug Cortex M3.</p>

<p><strong>Table 4 MEM-AP registers</strong></p>

<table>
<thead><tr>
<th>Address</th>
<th>Bank</th>
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>0x00</td>
<td>0x00</td>
<td>CSW</td>
<td>Control/Status Word Register</td>
</tr>
<tr>
<td>0x04</td>
<td>0x00</td>
<td>TAR</td>
<td>Transfer Address Register</td>
</tr>
<tr>
<td>0x0C</td>
<td>0x00</td>
<td>DRW</td>
<td>Data Read/Write Register</td>
</tr>
<tr>
<td>0xFC</td>
<td>0x0F</td>
<td>IDR</td>
<td>Identification Register</td>
</tr>
</tbody>
</table><h3>
<a name="51-controlstatus-word-csw-register" class="anchor" href="#51-controlstatus-word-csw-register"><span class="octicon octicon-link"></span></a>5.1. Control/Status Word (CSW) Register</h3>

<p><code>CSW</code> register configures and controls accesses through the MEM-AP to or from a connect memory system.</p>

<p><strong>Table 5 Bit assignments for the MEM-AP Control/Status Word Register, CSW</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>[30:24]</td>
<td>Prot</td>
<td>Bus access protection control. This field enables the debugger to specify protection flags for a debug access.</td>
</tr>
<tr>
<td>[5:4]</td>
<td>AddrInc</td>
<td>Address auto-increment and packing mode.</td>
</tr>
<tr>
<td>[2:0]</td>
<td>Size</td>
<td>b000: 8 bits; b001: 16 bits; b010: 32 bits</td>
</tr>
</tbody>
</table><h3>
<a name="52-the-transfer-address-register-tar" class="anchor" href="#52-the-transfer-address-register-tar"><span class="octicon octicon-link"></span></a>5.2. The Transfer Address Register (TAR)</h3>

<p><code>TAR</code> register holds the memory address  to be accessed.
The contents of TAR can be incremented automatically on a successful DRW access with b01 set in <code>AddrInc</code> field of <code>CSW</code> register.</p>

<h3>
<a name="53-the-data-readwrite-register-drw" class="anchor" href="#53-the-data-readwrite-register-drw"><span class="octicon octicon-link"></span></a>5.3. The Data Read/Write Register (DRW)</h3>

<p><code>DRW</code> register is used to either write or read from the address held in TAR. To write a value to an internal memory address, first write the address to the TAR register,
then write the value to DRW. To read a memory address, first write the address to TAR, then read the value in DRW.</p>

<h3>
<a name="54-the-identification-register-idr" class="anchor" href="#54-the-identification-register-idr"><span class="octicon octicon-link"></span></a>5.4. The Identification Register, (IDR)</h3>

<p><code>IDR</code> register identifies the Access Port. To read this register, the APBANKSEL field should be set to 0xF. And then IDR register can be read with address 0x0C(ADDR[3:2] = b11). The IDR register should return the value 0x24770011 on devices with a Cortex-M3 or Cortex-M4 core. On devices with a Cortex-M0+ it should return 0x0477003</p>

<p><img src="https://raw.github.com/MarkDing/swd_programing_sram/master/images/idr-reg.png" alt="IDR REG" title="The AP Identification Register, IDR"></p>

<h2>
<a name="6-debug-and-system-registers" class="anchor" href="#6-debug-and-system-registers"><span class="octicon octicon-link"></span></a>6. Debug and system Registers</h2>

<p>This section will go through the Cortex M3 Debug registers. With debug registers, we can set core into halt mode and can change core registers, like SP or PC.</p>

<p><strong>Table 6 Debug and system registers</strong></p>

<table>
<thead><tr>
<th>Address</th>
<th>Name</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>0xE000EDF0</td>
<td>DHCSR</td>
<td>Debug Halting Control and Status Register</td>
</tr>
<tr>
<td>0xE000EDF4</td>
<td>DCRSR</td>
<td>Debug Core Register Selector Register</td>
</tr>
<tr>
<td>0xE000EDF8</td>
<td>DCRDR</td>
<td>Debug Core Register Data Register</td>
</tr>
<tr>
<td>0xE000EDFC</td>
<td>DEMCR</td>
<td>Debug Exception and Monitor Control Register</td>
</tr>
<tr>
<td>0xE000ED0C</td>
<td>AIRCR</td>
<td>Application Interrupt and Reset Control Register</td>
</tr>
</tbody>
</table><h3>
<a name="61-debug-halting-control-and-status-register-dhcsr" class="anchor" href="#61-debug-halting-control-and-status-register-dhcsr"><span class="octicon octicon-link"></span></a>6.1. Debug Halting Control and Status Register, DHCSR</h3>

<p><code>DHCSR</code> register controls halting debug. Halting debug is enabled when C_DEBUGEN is set to 1.</p>

<p><strong>Table 7 DHCSR bit assignments</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Name</th>
<th>Function</th>
</tr></thead>
<tbody>
<tr>
<td>[31:16]</td>
<td>DBGKEY</td>
<td>Debug key: A debugger must write 0xA05Fto this field to enable write accesses to bits [15:0], otherwise the processor ignores the write access.</td>
</tr>
<tr>
<td>[16]</td>
<td>S_REGRDY</td>
<td>A handshake flag for transfers through the DCRDR: 0 = There has been a write to the DCRDR, but the transfer is not complete; 1 = The transfer to or from the DCRDR is complete.</td>
</tr>
<tr>
<td>[0]</td>
<td>C_DEBUGEN</td>
<td>Halting debug enable bit: 1 = Enabled</td>
</tr>
</tbody>
</table><h3>
<a name="62-debug-core-register-selector-register-dcrsr" class="anchor" href="#62-debug-core-register-selector-register-dcrsr"><span class="octicon octicon-link"></span></a>6.2. Debug Core Register Selector Register, DCRSR</h3>

<p><code>DCRSR</code> register provides debug access to the ARM core registers, special-purpose registers, and Floating-point extension registers. A write to DCRSR specifies the resister to transfer.</p>

<p><strong>Table 8 DCRSR bit assignments</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Name</th>
<th>Function</th>
</tr></thead>
<tbody>
<tr>
<td>[16]</td>
<td>REGWnR</td>
<td>0 = read; 1= write</td>
</tr>
<tr>
<td>[6:0]</td>
<td>REGSEL</td>
<td>Specifies the ARM core register, special-purpose register, or Floating-point extension register, to transfer: R0-R12, SP, LR, DebugReturnAddr, xPSR, MSP, PSP, etc.</td>
</tr>
</tbody>
</table><p>DebugReturnAddress is the address of the first instruction to be executed on exit from Debug state.</p>

<h3>
<a name="63-debug-core-register-data-register-dcrdr" class="anchor" href="#63-debug-core-register-data-register-dcrdr"><span class="octicon octicon-link"></span></a>6.3. Debug Core Register Data Register, DCRDR</h3>

<p><code>DCRDR</code> register provides debug access to ARM core register, special-purpose registers,and Floating-point extension registers. The DCRDR is the data register for these accesses.</p>

<p><strong>Use of DCRSR and DCRDR</strong></p>

<ul>
<li>To transfer a data word to an ARM core register, special-purpose register, orFloating-point extension register, a debugger:

<ul>
<li>Writes the required word to DCRDR.</li>
<li>Writes to the DCRSR, with the REGSEL value indicating the required register, and the REGWnR bit as 1 to indicate a write access. This write clears the DHCSR S_REGRDY bit to 0.</li>
<li>If required, polls DHCSR until DHCSR.S_REGRDY reads-as-one. This shows that the processor has transferred the DCRDR value to the selected register.</li>
</ul>
</li>
<li>To transfer a data word from an ARM core register, special-purpose register, or Floating-point extension register, a debugger:

<ul>
<li>Writes to the DCRSR, with the REGSEL value indicating the required register, and the REGWnR bit as 0 to indicate a read access. This write clears the DHCSR.S_REGRDY bit to 0.</li>
<li>Polls DHCSR until DHCSR.S_REGRDY reads-as-one. This shows that the processor has transferred the value of the selected register to DCRDR.</li>
<li>Reads the required value from DCRDR.</li>
</ul>
</li>
</ul><h3>
<a name="64-debug-exception-and-monitor-control-register-demcr" class="anchor" href="#64-debug-exception-and-monitor-control-register-demcr"><span class="octicon octicon-link"></span></a>6.4. Debug Exception and Monitor Control Register, DEMCR</h3>

<p><code>DEMCR</code> register manages vector catch behavior and DebugMonitor handling when debugging. Bits [23:16] provide DebugMonitor exception control. Bits [15:0] provide Debug state, halting debug, control.</p>

<p><strong>Table 9 DEMCR bit assignments</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Name</th>
<th>Function</th>
</tr></thead>
<tbody>
<tr>
<td>[10]</td>
<td>VC_HARDERR</td>
<td>Enable halting debug trap on a HardFault exception</td>
</tr>
<tr>
<td>[9]</td>
<td>VC_INTERR</td>
<td>Enable halting debug trap on a fault occurring during exception entry or exception return.</td>
</tr>
<tr>
<td>[8]</td>
<td>VC_BUSERR</td>
<td>Enable halting debug trap on a BusFault exception.</td>
</tr>
<tr>
<td>[7]</td>
<td>VC_STATERR</td>
<td>Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception.</td>
</tr>
<tr>
<td>[6]</td>
<td>VC_CHKERR</td>
<td>Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error.</td>
</tr>
<tr>
<td>[5]</td>
<td>VC_NOCPERR</td>
<td>Enable halting debug trap on a UsageFault caused by an access to a Coprocessor.</td>
</tr>
<tr>
<td>[4]</td>
<td>VC_MMERR</td>
<td>Enable halting debug trap on a MemManage exception.</td>
</tr>
<tr>
<td>[0]</td>
<td>VC_CORERESET</td>
<td>Enable Reset Vector Catch. This causes a Local reset to halt a running system.</td>
</tr>
</tbody>
</table><p>Vector catch is the mechanism for generating a debug event and entering Debug state when a particular exception occurs. Vector catching is only supported by halting debug.</p>

<h3>
<a name="65-application-interrupt-and-reset-control-register-aircr" class="anchor" href="#65-application-interrupt-and-reset-control-register-aircr"><span class="octicon octicon-link"></span></a>6.5. Application Interrupt and Reset Control Register, AIRCR</h3>

<p><code>AIRCR</code> register sets or returns interrupt control data.</p>

<p><strong>Table 10 AIRCR bit assignments</strong></p>

<table>
<thead><tr>
<th>Bits</th>
<th>Name</th>
<th>Function</th>
</tr></thead>
<tbody>
<tr>
<td>[31:16]</td>
<td>VECTKEY</td>
<td>Vector Key. Register writes must write 0x05FAto this field, otherwise the write is ignored.On reads, returns 0xFA05.</td>
</tr>
<tr>
<td>[15]</td>
<td>ENDIANNESS</td>
<td>0 = Little endian; 1 = Big endian</td>
</tr>
<tr>
<td>[10:8]</td>
<td>PRIGROUP</td>
<td>Priority grouping</td>
</tr>
<tr>
<td>[2]</td>
<td>SYSRESETREQ</td>
<td>Writing 1 to this bit asserts a signal to the external system to request a Local reset.</td>
</tr>
<tr>
<td>[1]</td>
<td>VECTCLRACTIVE</td>
<td>Writing 1 to this bit clears all active state information for fixed and configurable exceptions.</td>
</tr>
<tr>
<td>[0]</td>
<td>VECTRESET</td>
<td>Writing 1 to this bit causes a local system reset.</td>
</tr>
</tbody>
</table><h2>
<a name="7-sram-programing" class="anchor" href="#7-sram-programing"><span class="octicon octicon-link"></span></a>7. SRAM programing</h2>

<p>This section demonstrate step by step how to programming internal SRAM over SWD.</p>

<h3>
<a name="71-initialization" class="anchor" href="#71-initialization"><span class="octicon octicon-link"></span></a>7.1. Initialization</h3>

<p>Before suing the SW-DP an initialization sequence must be performed to establish communication and bring the SW-DP to a know state.</p>

<ul>
<li>Send more than 50 SWCLKTCK cycles with SWDIOTMS=1. This ensures that both SWD and JTAG are in their reset states.</li>
<li>Send the 16-bit JTAG-to-SWD select sequence on SWDIOTMS</li>
<li>Send more than 50 SWCLKTCK cycles with SWDIOTMS=1. This ensures that if SWJ-DP was already in SWD mode, before sending the select sequence, the SWD goes to line reset.</li>
<li>Perform a READID to validate that SWJ-DP has switched to SWD operation.</li>
</ul><h3>
<a name="72-halt-the-core" class="anchor" href="#72-halt-the-core"><span class="octicon octicon-link"></span></a>7.2. Halt the core</h3>

<p>Before programming internal SRAM, the ARM Cortex M3 should first be reset and halted. It gets the core and peripherals into a know state and prohibit the core from accidentally running partial code while writing the program.</p>

<p>There debug and system registers and one Silabs extent AP register CHIPAP_CTRL1 are used for this purpose.
CHIPAP_CTRL1 address = 0x1, APSEL = 0x0A. bit 3 core_reset_ap, To hold the CortexM3 core in reset this bit should be written to one.</p>

<p>The process is as follow:</p>

<ul>
<li>Write 0x08 to CHIPAP_CTRL1.</li>
<li>Write 0xA05F0001 to DHCSR, which halting debug enabled.</li>
<li>Write 0x01 to DEMCR. This enable Reset Vector Catch.</li>
<li>Write 0xFA050004 to AIRCR. This reset the core.</li>
<li>Write 0x00 to CHIPAP_CTRL1.</li>
</ul><p>Now the core will be halted on first instruction and all peripherals and registers will have their reset value.</p>

<h3>
<a name="73-memory-and-core-register-access" class="anchor" href="#73-memory-and-core-register-access"><span class="octicon octicon-link"></span></a>7.3. Memory and core register access.</h3>

<h3>
<a name="731-access-memory" class="anchor" href="#731-access-memory"><span class="octicon octicon-link"></span></a>7.3.1 Access memory</h3>

<ul>
<li>Set 32 bit width and auto increment in CSW register.</li>
<li>Write memory address in TAR register</li>
<li>Access DRW register for read/write data.</li>
</ul><p>Here is the python script example</p>

<div class="highlight highlight-python"><pre><span class="k">def</span> <span class="nf">swd_write_mem</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">data_ws</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="c"># Auto increment addresses</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">DP_SELECT</span><span class="p">,</span> <span class="n">MEMAP_BANK_0</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_CSW</span><span class="p">,</span> <span class="mh">0x23000012</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">,</span> <span class="n">data_ws</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">swd_read_mem</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">data_ws</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Auto increment addresses</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">DP_SELECT</span><span class="p">,</span> <span class="n">MEMAP_BANK_0</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_CSW</span><span class="p">,</span> <span class="mh">0x23000012</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="n">uda</span><span class="o">.</span><span class="n">QueueRead</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">)</span>
        <span class="n">data_ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">data_ws</span>
</pre></div>

<h3>
<a name="732-access-core-registers" class="anchor" href="#732-access-core-registers"><span class="octicon octicon-link"></span></a>7.3.2 Access core registers</h3>

<p><strong>Read:</strong></p>

<ul>
<li>Set 32 bit width in CSW register</li>
<li>Write DCRSR address into TAR register.</li>
<li>Write core register index Rn into DRW register.</li>
<li>Write DCRDR address into TAR register.</li>
<li>Read core register value from DRW register.</li>
</ul><p><strong>Write:</strong></p>

<ul>
<li>Set 32 bit width in CSW register</li>
<li>Write DCRDR address into TAR register.</li>
<li>Write core value into DRW register.</li>
<li>Write DCRSR address into TAR register.</li>
<li>Write core register index Rn and REGWnR = 1 into DRW register.</li>
</ul><p>Here is the python script example</p>

<div class="highlight highlight-Python"><pre><span class="k">def</span> <span class="nf">swd_write_core_register</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">DP_SELECT</span><span class="p">,</span> <span class="n">MEMAP_BANK_0</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_CSW</span><span class="p">,</span> <span class="mh">0x23000002</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">DCRDR</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">DCRSR</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">,</span> <span class="n">n</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">swd_read_core_register</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">DP_SELECT</span><span class="p">,</span> <span class="n">MEMAP_BANK_0</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_CSW</span><span class="p">,</span> <span class="mh">0x23000002</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">DCRSR</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueWrite</span><span class="p">(</span><span class="n">MEMAP_TAR</span><span class="p">,</span> <span class="n">DCRDR</span><span class="p">)</span>
    <span class="n">uda</span><span class="o">.</span><span class="n">QueueRead</span><span class="p">(</span><span class="n">MEMAP_DRW</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">uda</span><span class="o">.</span><span class="n">StartTransfers</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">val</span>
</pre></div>

<h3>
<a name="733-programming-firmware-into-internal-sram" class="anchor" href="#733-programming-firmware-into-internal-sram"><span class="octicon octicon-link"></span></a>7.3.3 Programming firmware into internal SRAM</h3>

<p>The process is followed</p>

<ul>
<li>Read firmware from disk.</li>
<li>Write firmware into internal SRAM by swd_write_mem() function.</li>
<li>Read back firmware by swd_read_mem() to verify the integrity.</li>
<li>Update vector table entry in 0xe000ed08 to SRAM start position 0x20000000.</li>
<li>Update R15(PC) with reset vector address. It locates at second word position in firmware.</li>
<li>Update R13(SP) with stack address defined in first word in firmware.</li>
<li>Exist debug mode by writing 0xA05F0000 into DHCSR register.</li>
</ul><p>Here is the python script example</p>

<div class="highlight highlight-Python"><pre>    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"sim3u1xx_USBHID_ram.bin"</span><span class="p">,</span><span class="n">mode</span> <span class="o">=</span> <span class="s">'rb'</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">swd_write_mem</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="mh">0x20000000</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="n">swd_write_mem</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="mh">0xe000ed08</span><span class="p">,</span> <span class="mh">0x20000000</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">swd_write_core_register</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span> <span class="mh">0xFFFFFFFE</span><span class="p">)</span>
    <span class="n">swd_write_core_register</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">write_AHB</span><span class="p">(</span><span class="n">uda</span><span class="p">,</span> <span class="n">DHCSR</span><span class="p">,</span> <span class="mh">0xA05F0000</span><span class="p">)</span>
</pre></div>

<p>Then we can see firmware runs from internal SRAM.</p>

<h2>
<a name="8-source-code" class="anchor" href="#8-source-code"><span class="octicon octicon-link"></span></a>8. Source code</h2>

<p>Source code can be found at <a href="https://github.com/MarkDing/swd_programing_sram">https://github.com/MarkDing/swd_programing_sram</a></p>

<h2>
<a name="9-reference" class="anchor" href="#9-reference"><span class="octicon octicon-link"></span></a>9. Reference</h2>

<ul>
<li>
<code>Adi5</code> ARM Debug Interface v5 Architecture Specification.</li>
<li>
<code>Adi51</code> ARM Debug Interface v5 Architecture Specification ADIv5.1 Supplement.</li>
<li>
<code>Cm3trm</code> Cortex-M3 Revision r2p1 Technical Reference Manual</li>
<li>
<code>ARMv7-M</code> ARMv7-M Architecture Reference Manual</li>
<li>
<code>CoreSight DAP-Lite</code> CoreSight DAP-Lite Technical Reference Manual</li>
</ul><h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>LICENSE</h2>

<p>The MIT License (MIT)</p>

<p>Copyright (c) 2014 Mark Ding(<a href="mailto:mark.ding@hotmail.com">mark.ding@hotmail.com</a>)</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sub-license, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Swd programing sram maintained by <a href="https://github.com/MarkDing">MarkDing</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
